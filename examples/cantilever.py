from __future__ import print_function, division
import sys, petsc4py
petsc4py.init(sys.argv)
import mpi4py.MPI as mpi
from petsc4py import PETSc
import numpy as np

from random import randrange

from random import choices

from random import seed

from numpy.linalg import inv

from pyComp import *

comm = mpi.COMM_WORLD

class Cantilever():

    def __init__(self, param, comm):

        self.dim = 3

        self.comm = comm

        self.param = param

        self.numPlies = 3

        self.numDataPoints = 12

        self.numInterfaces = self.numPlies - 1

        self.numLayers = self.numPlies + self.numInterfaces

        self.t = np.asarray([0.2, 0.02, 0.2, 0.02, 0.2])

        self.theta = np.asarray([np.pi/4, -123.0, 0.0, -123.0, 3.*np.pi/4])

        self.cutoff = np.cumsum(self.t)

        nx = 50
        ny = 10

        Lx = 10.
        Ly = 2.


        self.nel_per_layer = np.asarray([2,2,2,2,2])

        self.isBnd = lambda x: self.isBoundary(x)

        self.f = lambda x: self.rhs(x)

        self.da = LayerCake(nx, ny, Lx, Ly, self.t, self.nel_per_layer) # Build layered composite from uniform mesh

        # Setup global and local matrices + communicators

        self.A = self.da.createMatrix()
        r, _ = self.A.getLGMap() # Get local to global mapping
        self.is_A = PETSc.IS().createGeneral(r.indices) # Create Index Set for local indices
        A_local = self.A.createSubMatrices(self.is_A)[0] # Construct local submatrix on domain
        vglobal = self.da.createGlobalVec()
        vlocal = self.da.createLocalVec()
        self.scatter_l2g = PETSc.Scatter().create(vlocal, None, vglobal, self.is_A)

        self.A_local = A_local

        # Setup elements
        self.fe = ElasticityQ1()

        # Compute Material Tensor given material parameters

        self.isotropic, self.composite = makeMaterials(self.param)

        #

        self.getDataDof()


    def isBoundary(self, x):
        # User defined function which marks boundary conditions.
        # In this case x = 0 is clamped with all degrees of freedom set to 0.0
        vals = [0.0, 0.0, 0.0]
        output = False
        dofs = None
        if(x[0] < 1e-6):
            output = True
            dofs = [0, 1, 2]
        return output, dofs, vals

    def getDataDof(self):

        self.nnodes = int(self.da.getCoordinatesLocal()[ :].size/self.dim) # Total nodes on local processor

        self.coords = np.transpose(self.da.getCoordinatesLocal()[:].reshape((self.nnodes,self.dim)))

        dofListTopSurface = []

        for i in range(self.nnodes):
            if(self.coords[2,i] > np.sum(self.t) - 1e-6):
                dofListTopSurface.append(i)

        assert len(dofListTopSurface) > self.numDataPoints, "numDataPoints > than num nodes on top surface"

        seed(123) # So the data points are the same

        tmp = choices(dofListTopSurface, k=self.numDataPoints)

        self.Qdof = np.zeros(len(tmp), dtype = np.int32)

        for i in range(len(tmp)):
            self.Qdof[i] = 3 * tmp[i] + 2


    def rhs(self, x):
        # Defines source term for load vectors
        # In this case simple gravity
        output = np.zeros((3,))
        output[2] = -9.81 * 0.0001
        return output

    def setTheta(self, angles):

        #assert angles.shape[0] == self.numPlies, "Length of angles is not equal to number of plies"
        self.theta[0] = angles[0]
        self.theta[2] = angles[1]
        self.theta[4] = angles[2]

    def whichLayer(self, z):
        # For a flat laminate (generated by LayerCake) return layer id based on z coordinate.
        flag = False
        ans = 0
        for i in range(self.numLayers): # Loop Through Each Layer
            if((z < self.cutoff[i]) and flag == False):
                ans = i
                flag = True

        return ans

    def getIndices(self,elem, dof = 3):
        ind = np.empty(dof*elem.size, dtype=np.int32)
        for i in range(dof):
            ind[i::dof] = dof*elem + i
        return ind

    def solve(self, theta, plotSolution = False, filename = "solution", iterativeSolver = True):

        self.setTheta(theta)

        self.A = self.da.createMatrix() # Initialise Distributed 'A' Matrix

        b = self.da.createGlobalVec() # Initialise Distributed 'b' vector
        b_local = self.da.createLocalVec() # Initialise Local 'b' vector

        elem = self.da.getElements() # Collect node ids for each element

        nnodes = int(self.da.getCoordinatesLocal()[ :].size/self.dim) # Total nodes on local processor

        coords = np.transpose(self.da.getCoordinatesLocal()[:].reshape((nnodes,self.dim))) # Coordinates associated with local nodes

        # **** Assemble Stiffness matrices and load vectors

        for ie, e in enumerate(elem,0): # Loop over all local elements

            midpoint_z = np.mean(coords[2,e]) # Finds z-coordinate of midpoint

            layerId = np.int(self.whichLayer(midpoint_z)) # Finds which layer element lives in
            isComposite = False

            if(self.theta[layerId] >= -100.0): # Composite - theta is greater than 0
                C = self.composite
                isComposite = True
                angle = self.theta[layerId]
            else: # Isotropic - marked with negative theta values
                C = self.isotropic
                angle = None

            # Compute Element Stiffness Matrix

            Ke = self.fe.getLocalStiffness(coords[:,e], C, isComposite, angle)

            ind = self.getIndices(e) # Local to global mapping

            self.A.setValuesLocal(ind, ind, Ke, PETSc.InsertMode.ADD_VALUES)

            # Compute Element load vector

            b_local[ind] = self.fe.getLoadVec(coords[:,e],  self.f)

        self.A.assemble()


        # --- Implement Boundary Conditions
        rows = []
        for i in range(nnodes):
            flag, dofs, vals = self.isBoundary(coords[:,i])
            if(flag): # It's Dirichlet
                for j in range(len(dofs)): # For each of the constrained dofs
                    index = 3 * i + dofs[j]
                    rows.append(index)
                    b_local[index] = vals[j]
        rows = np.asarray(rows,dtype=np.int32)

        self.A.zeroRowsLocal(rows, diag = 1.0)

        self.scatter_l2g(b_local, b, PETSc.InsertMode.INSERT_VALUES)

        # --- Solve

        # Setup solution Vector
        x = self.da.createGlobalVec()
        x.setRandom()
        xnorm = b.dot(x)/x.dot(self.A*x)
        x *= xnorm

        # Setup Solver
        ksp = PETSc.KSP().create()
        pc = ksp.getPC()

        if(iterativeSolver):
            # Default option uses CG for iterative solver preconditioned with gamg
            ksp.setType('cg')
            pc.setType('gamg')
        else:
            # Direct solver
            ksp.setType('preonly')
            pc.setType('lu')
            #pc.setFactorSolverPackage('mumps')


        ksp.setOperators(self.A)
        if(iterativeSolver):
            ksp.setInitialGuessNonzero(True)
        ksp.setFromOptions()
        ksp.solve(b, x) # Solution of A * x = b

        # Plot solution to vts file for visualisation in paraview
        if(plotSolution):
            viewer = PETSc.Viewer().createVTK(filename + ".vts", 'w', comm = comm)
            x.view(viewer)
            viewer.destroy()

        # Post process all quantities of interest

        Q = x[self.Qdof]

        return Q




param = [ None ] * 11

param[0] = 4.5  # E_R   GPa
param[1] = 0.35 # nu_R

param[2] = 135  # E1    GPa
param[3] = 8.5  # E2    GPa
param[4] = 8.5  # E3    GPa

param[5] = 0.022    # nu_21
param[6] = 0.022    # nu_31
param[7] = 0.45     # nu_32

param[8] = 5.0  # G_12 GPa
param[9] = 5;   # G_13 GPa
param[10] = 5;  # G_23 GPa

np.random.seed(1234) # Set seed so same each time for testing

Nsamples = 30

baseAngles = [np.pi/4, 0.0, -np.pi/4]

theta = np.random.normal(0.0, 0.0872665, size = (Nsamples, 3)) #

myModel = Cantilever(param, comm)

for i in range(Nsamples):

    print("This is Sample " + str(i))

    print(theta[i,:])

    F = myModel.solve(baseAngles + theta[i,:], True, iterativeSolver = False)

    print(F)
